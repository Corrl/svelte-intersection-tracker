import{S,i as j,s as N,K as G,L as X,M as Z,q as k,o as I,l as F,g as R,n as ee,p as te,N as re,d as u,O as x,I as ie,e as v,k as V,c as y,a as _,m as q,b as m,J as b,v as oe,P as se,Q as ae,w as B,x as M,y as W,B as D,t as E,h as T,R as P,j as O,f as le}from"../chunks/index-2160b39e.js";import{d as he,w as ce}from"../chunks/index-976d7874.js";const A=ce([]),ne=he(A,n=>{const r=Math.max(...n);return n.reduce((s,a,t)=>a===r?s.concat(t):s,[])});function L(n,r,s){const a=n.slice();return a[5]=r[s],a[7]=s,a}const de=n=>({d:n&1,current:n&2,percentage:n&4}),H=n=>{var r;return{d:n[5],current:n[1].includes(n[7]),percentage:(r=n[2][n[7]])!=null?r:0}};function Y(n){let r;const s=n[4].default,a=ie(s,n,n[3],H);return{c(){a&&a.c()},l(t){a&&a.l(t)},m(t,h){a&&a.m(t,h),r=!0},p(t,h){a&&a.p&&(!r||h&15)&&G(a,s,t,t[3],r?Z(s,t[3],h,de):X(t[3]),H)},i(t){r||(k(a,t),r=!0)},o(t){I(a,t),r=!1},d(t){a&&a.d(t)}}}function ge(n){let r,s,a=n[0],t=[];for(let o=0;o<a.length;o+=1)t[o]=Y(L(n,a,o));const h=o=>I(t[o],1,1,()=>{t[o]=null});return{c(){for(let o=0;o<t.length;o+=1)t[o].c();r=F()},l(o){for(let e=0;e<t.length;e+=1)t[e].l(o);r=F()},m(o,e){for(let i=0;i<t.length;i+=1)t[i].m(o,e);R(o,r,e),s=!0},p(o,[e]){if(e&15){a=o[0];let i;for(i=0;i<a.length;i+=1){const c=L(o,a,i);t[i]?(t[i].p(c,e),k(t[i],1)):(t[i]=Y(c),t[i].c(),k(t[i],1),t[i].m(r.parentNode,r))}for(ee(),i=a.length;i<t.length;i+=1)h(i);te()}},i(o){if(!s){for(let e=0;e<a.length;e+=1)k(t[e]);s=!0}},o(o){t=t.filter(Boolean);for(let e=0;e<t.length;e+=1)I(t[e]);s=!1},d(o){re(t,o),o&&u(r)}}}function ue(n,r,s){let a,t;x(n,ne,i=>s(1,a=i)),x(n,A,i=>s(2,t=i));let{$$slots:h={},$$scope:o}=r,{data:e}=r;return n.$$set=i=>{"data"in i&&s(0,e=i.data),"$$scope"in i&&s(3,o=i.$$scope)},[e,a,t,o,h]}class fe extends S{constructor(r){super(),j(this,r,ue,ge,N,{data:0})}}function J(n,r,s){const a=n.slice();return a[7]=r[s],a[8]=r,a[9]=s,a}const be=n=>({d:n&1,current:n&8,percentage:n&4}),K=n=>{var r;return{d:n[7],current:n[3].includes(n[9]),percentage:(r=n[2][n[9]])!=null?r:0}};function Q(n){let r,s,a,t=n[9],h;const o=n[5].default,e=ie(o,n,n[4],K),i=()=>n[6](r,t),c=()=>n[6](null,t);return{c(){r=v("div"),e&&e.c(),s=V(),this.h()},l(l){r=y(l,"DIV",{"data-index":!0,class:!0});var d=_(r);e&&e.l(d),s=q(d),d.forEach(u),this.h()},h(){m(r,"data-index",a=n[9]),m(r,"class","svelte-qjko8r")},m(l,d){R(l,r,d),e&&e.m(r,null),b(r,s),i(),h=!0},p(l,d){n=l,e&&e.p&&(!h||d&29)&&G(e,o,n,n[4],h?Z(o,n[4],d,be):X(n[4]),K),t!==n[9]&&(c(),t=n[9],i())},i(l){h||(k(e,l),h=!0)},o(l){I(e,l),h=!1},d(l){l&&u(r),e&&e.d(l),c()}}}function me(n){let r,s,a=n[0],t=[];for(let o=0;o<a.length;o+=1)t[o]=Q(J(n,a,o));const h=o=>I(t[o],1,1,()=>{t[o]=null});return{c(){for(let o=0;o<t.length;o+=1)t[o].c();r=F()},l(o){for(let e=0;e<t.length;e+=1)t[e].l(o);r=F()},m(o,e){for(let i=0;i<t.length;i+=1)t[i].m(o,e);R(o,r,e),s=!0},p(o,[e]){if(e&31){a=o[0];let i;for(i=0;i<a.length;i+=1){const c=J(o,a,i);t[i]?(t[i].p(c,e),k(t[i],1)):(t[i]=Q(c),t[i].c(),k(t[i],1),t[i].m(r.parentNode,r))}for(ee(),i=a.length;i<t.length;i+=1)h(i);te()}},i(o){if(!s){for(let e=0;e<a.length;e+=1)k(t[e]);s=!0}},o(o){t=t.filter(Boolean);for(let e=0;e<t.length;e+=1)I(t[e]);s=!1},d(o){re(t,o),o&&u(r)}}}function we(n,r,s){let a,t;x(n,A,l=>s(2,a=l)),x(n,ne,l=>s(3,t=l));let{$$slots:h={},$$scope:o}=r,{data:e}=r,i=[];oe(()=>{const l={threshold:Array.from({length:101},(p,g)=>g/100)},d=new IntersectionObserver(w,l);i.forEach(p=>d.observe(p));function w(p){p.forEach(g=>{const f=g.target.dataset.index,$=g.intersectionRatio,C=g.intersectionRect.height/g.rootBounds.height;se(A,a[f]=Math.max($.toFixed(2),C.toFixed(2)),a)})}return()=>d.disconnect()});function c(l,d){ae[l?"unshift":"push"](()=>{i[d]=l,s(1,i)})}return n.$$set=l=>{"data"in l&&s(0,e=l.data),"$$scope"in l&&s(4,o=l.$$scope)},[e,i,a,t,o,h,c]}class pe extends S{constructor(r){super(),j(this,r,we,me,N,{data:0})}}const U=[{id:"title1",title:"Title 1",content:`Either a single number or an array of numbers which indicate at what percentage of the target's visibility the observer's callback should be executed. If you only want to detect when visibility passes the 50% mark, you can use a value of 0.5. If you want the callback to run every time visibility passes another 25%, you would specify the array [0, 0.25, 0.5, 0.75, 1].

 The default is 0 (meaning as soon as even one pixel is visible, the callback will be run). A value of 1.0 means that the threshold isn't considered passed until every pixel is visible. Either a single number or an array of numbers which indicate at what percentage of the target's visibility the observer's callback should be executed. If you only want to detect when visibility passes the 50% mark, you can use a value of 0.5. If you want the callback to run every time visibility passes another 25%, you would specify the array [0, 0.25, 0.5, 0.75, 1]. The default is 0 (meaning as soon as even one pixel is visible, the callback will be run). A value of 1.0 means that the threshold isn't considered passed until every pixel is visible.`},{id:"title2",title:"Title 2",content:`Rather than reporting every infinitesimal change in how much a target element is visible, the Intersection Observer API uses thresholds. When you create an observer, you can provide one or more numeric values representing percentages of the target element which are visible. Then, the API only reports changes to visibility which cross these thresholds.

For example, if you want to be informed every time a target's visibility passes backward or forward through each 25% mark, you would specify the array [0, 0.25, 0.5, 0.75, 1] as the list of thresholds when creating the observer.

When the callback is invoked, it receives a list of IntersectionObserverEntry objects, one for each observed target which has had the degree to which it intersects the root change such that the amount exposed crosses over one of the thresholds, in either direction.

You can see if the target currently intersects the root by looking at the entry's isIntersecting property; if its value is true, the target is at least partially intersecting the root element or document. This lets you determine whether the entry represents a transition from the elements intersecting to no longer intersecting or a transition from not intersecting to intersecting.

Note that it's possible to have a non-zero intersection rectangle, which can happen if the intersection is exactly along the boundary between the two or the area of boundingClientRect is zero. This state of the target and root sharing a boundary line is not considered enough to be considered transitioning into an intersecting state.

To get a feeling for how thresholds work, try scrolling the box below around. Each colored box within it displays the percentage of itself that's visible in all four of its corners, so you can see these ratios change over time as you scroll the container. Each box has a different set of thresholds:

The first box has a threshold for each percentage point of visibility; that is, the IntersectionObserver.thresholds array is [0.00, 0.01, 0.02, ..., 0.99, 1.00].
The second box has a single threshold, at the 50% mark.
The third box has thresholds every 10% of visibility (0%, 10%, 20%, etc.).
The last box has thresholds each 25%.`},{id:"title3",title:"Title 3",content:"Historically, detecting visibility of an element, or the relative visibility of two elements in relation to each other, has been a difficult task for which solutions have been unreliable and prone to causing the browser and the sites the user is accessing to become sluggish. As the web has matured, the need for this kind of information has grown. Intersection information is needed for many reasons, such as: Each entry in the list of thresholds is an IntersectionObserverEntry object describing one threshold that was crossed; that is, each entry describes how much of a given element is intersecting with the root element, whether or not the element is considered to be intersecting or not, and the direction in which the transition occurred."},{id:"title4",title:"Title 4",content:`For each IntersectionObserverEntry in the list entries, we look to see if the entry's intersectionRatio is going up; if it is, we set the target's background-color to the string in increasingColor (remember, it's "rgba(40, 40, 190, ratio)"), replaces the word "ratio" with the entry's intersectionRatio. The result: not only does the color get changed, but the transparency of the target element changes, too; as the intersection ratio goes down, the background color's alpha value goes down with it, resulting in an element that's more transparent.

Similarly, if the intersectionRatio is going down, we use the string decreasingColor and replace the word "ratio" in that with the intersectionRatio before setting the target element's background-color.

Finally, in order to track whether the intersection ratio is going up or down, we remember the current ratio in the variable prevRatio. For each IntersectionObserverEntry in the list entries, we look to see if the entry's intersectionRatio is going up; if it is, we set the target's background-color to the string in increasingColor (remember, it's "rgba(40, 40, 190, ratio)"), replaces the word "ratio" with the entry's intersectionRatio. The result: not only does the color get changed, but the transparency of the target element changes, too; as the intersection ratio goes down, the background color's alpha value goes down with it, resulting in an element that's more transparent.

Similarly, if the intersectionRatio is going down, we use the string decreasingColor and replace the word "ratio" in that with the intersectionRatio before setting the target element's background-color.

Finally, in order to track whether the intersection ratio is going up or down, we remember the current ratio in the variable prevRatio. For each IntersectionObserverEntry in the list entries, we look to see if the entry's intersectionRatio is going up; if it is, we set the target's background-color to the string in increasingColor (remember, it's "rgba(40, 40, 190, ratio)"), replaces the word "ratio" with the entry's intersectionRatio. The result: not only does the color get changed, but the transparency of the target element changes, too; as the intersection ratio goes down, the background color's alpha value goes down with it, resulting in an element that's more transparent.

Similarly, if the intersectionRatio is going down, we use the string decreasingColor and replace the word "ratio" in that with the intersectionRatio before setting the target element's background-color.

Finally, in order to track whether the intersection ratio is going up or down, we remember the current ratio in the variable prevRatio. For each IntersectionObserverEntry in the list entries, we look to see if the entry's intersectionRatio is going up; if it is, we set the target's background-color to the string in increasingColor (remember, it's "rgba(40, 40, 190, ratio)"), replaces the word "ratio" with the entry's intersectionRatio. The result: not only does the color get changed, but the transparency of the target element changes, too; as the intersection ratio goes down, the background color's alpha value goes down with it, resulting in an element that's more transparent.

Similarly, if the intersectionRatio is going down, we use the string decreasingColor and replace the word "ratio" in that with the intersectionRatio before setting the target element's background-color.

Finally, in order to track whether the intersection ratio is going up or down, we remember the current ratio in the variable prevRatio.For each IntersectionObserverEntry in the list entries, we look to see if the entry's intersectionRatio is going up; if it is, we set the target's background-color to the string in increasingColor (remember, it's "rgba(40, 40, 190, ratio)"), replaces the word "ratio" with the entry's intersectionRatio. The result: not only does the color get changed, but the transparency of the target element changes, too; as the intersection ratio goes down, the background color's alpha value goes down with it, resulting in an element that's more transparent.

Similarly, if the intersectionRatio is going down, we use the string decreasingColor and replace the word "ratio" in that with the intersectionRatio before setting the target element's background-color.

Finally, in order to track whether the intersection ratio is going up or down, we remember the current ratio in the variable prevRatio.For each IntersectionObserverEntry in the list entries, we look to see if the entry's intersectionRatio is going up; if it is, we set the target's background-color to the string in increasingColor (remember, it's "rgba(40, 40, 190, ratio)"), replaces the word "ratio" with the entry's intersectionRatio. The result: not only does the color get changed, but the transparency of the target element changes, too; as the intersection ratio goes down, the background color's alpha value goes down with it, resulting in an element that's more transparent.

Similarly, if the intersectionRatio is going down, we use the string decreasingColor and replace the word "ratio" in that with the intersectionRatio before setting the target element's background-color.

Finally, in order to track whether the intersection ratio is going up or down, we remember the current ratio in the variable prevRatio.`},{id:"title5",title:"Title 5",content:`Rather than reporting every infinitesimal change in how much a target element is visible, the Intersection Observer API uses thresholds. When you create an observer, you can provide one or more numeric values representing percentages of the target element which are visible. Then, the API only reports changes to visibility which cross these thresholds.

For example, if you want to be informed every time a target's visibility passes backward or forward through each 25% mark, you would specify the array [0, 0.25, 0.5, 0.75, 1] as the list of thresholds when creating the observer.

When the callback is invoked, it receives a list of IntersectionObserverEntry objects, one for each observed target which has had the degree to which it intersects the root change such that the amount exposed crosses over one of the thresholds, in either direction.

You can see if the target currently intersects the root by looking at the entry's isIntersecting property; if its value is true, the target is at least partially intersecting the root element or document. This lets you determine whether the entry represents a transition from the elements intersecting to no longer intersecting or a transition from not intersecting to intersecting.

Note that it's possible to have a non-zero intersection rectangle, which can happen if the intersection is exactly along the boundary between the two or the area of boundingClientRect is zero. This state of the target and root sharing a boundary line is not considered enough to be considered transitioning into an intersecting state.

To get a feeling for how thresholds work, try scrolling the box below around. Each colored box within it displays the percentage of itself that's visible in all four of its corners, so you can see these ratios change over time as you scroll the container. Each box has a different set of thresholds.`},{id:"title6",title:"Title 6",content:"Each entry in the list of thresholds is an IntersectionObserverEntry object describing one threshold that was crossed; that is, each entry describes how much of a given element is intersecting with the root element, whether or not the element is considered to be intersecting or not, and the direction in which the transition occurred."}];function ve(n){let r,s,a,t=n[0].title+"",h,o,e=n[2]+"",i,c;return{c(){r=v("li"),s=v("a"),a=v("span"),h=E(t),o=E(" - "),i=E(e),this.h()},l(l){r=y(l,"LI",{class:!0});var d=_(r);s=y(d,"A",{href:!0,class:!0});var w=_(s);a=y(w,"SPAN",{});var p=_(a);h=T(p,t),p.forEach(u),o=T(w," - "),i=T(w,e),w.forEach(u),d.forEach(u),this.h()},h(){m(s,"href",c="#"+n[0].id),m(s,"class","svelte-4br9cw"),m(r,"class","svelte-4br9cw"),P(r,"current-title",n[1])},m(l,d){R(l,r,d),b(r,s),b(s,a),b(a,h),b(s,o),b(s,i)},p(l,d){d&1&&t!==(t=l[0].title+"")&&O(h,t),d&4&&e!==(e=l[2]+"")&&O(i,e),d&1&&c!==(c="#"+l[0].id)&&m(s,"href",c),d&2&&P(r,"current-title",l[1])},d(l){l&&u(r)}}}function ye(n){let r,s,a=n[0].title+"",t,h,o,e=n[2]+"",i,c,l,d,w=n[0].content+"",p;return{c(){r=v("div"),s=v("h1"),t=E(a),h=E(" - "),o=v("span"),i=E(e),l=V(),d=v("p"),p=E(w),this.h()},l(g){r=y(g,"DIV",{class:!0});var f=_(r);s=y(f,"H1",{id:!0,class:!0});var $=_(s);t=T($,a),h=T($," - "),o=y($,"SPAN",{style:!0});var C=_(o);i=T(C,e),C.forEach(u),$.forEach(u),l=q(f),d=y(f,"P",{class:!0});var z=_(d);p=T(z,w),z.forEach(u),f.forEach(u),this.h()},h(){le(o,"font-weight","normal"),m(s,"id",c=n[0].id),m(s,"class","svelte-4br9cw"),m(d,"class","section-content svelte-4br9cw"),m(r,"class","item svelte-4br9cw"),P(r,"current-item",n[1])},m(g,f){R(g,r,f),b(r,s),b(s,t),b(s,h),b(s,o),b(o,i),b(r,l),b(r,d),b(d,p)},p(g,f){f&1&&a!==(a=g[0].title+"")&&O(t,a),f&4&&e!==(e=g[2]+"")&&O(i,e),f&1&&c!==(c=g[0].id)&&m(s,"id",c),f&1&&w!==(w=g[0].content+"")&&O(p,w),f&2&&P(r,"current-item",g[1])},d(g){g&&u(r)}}}function _e(n){let r,s,a,t,h,o;return s=new fe({props:{data:U,$$slots:{default:[ve,({d:e,current:i,percentage:c})=>({0:e,1:i,2:c}),({d:e,current:i,percentage:c})=>(e?1:0)|(i?2:0)|(c?4:0)]},$$scope:{ctx:n}}}),h=new pe({props:{data:U,$$slots:{default:[ye,({d:e,current:i,percentage:c})=>({0:e,1:i,2:c}),({d:e,current:i,percentage:c})=>(e?1:0)|(i?2:0)|(c?4:0)]},$$scope:{ctx:n}}}),{c(){r=v("ul"),B(s.$$.fragment),a=V(),t=v("div"),B(h.$$.fragment),this.h()},l(e){r=y(e,"UL",{class:!0});var i=_(r);M(s.$$.fragment,i),i.forEach(u),a=q(e),t=y(e,"DIV",{id:!0,class:!0});var c=_(t);M(h.$$.fragment,c),c.forEach(u),this.h()},h(){m(r,"class","svelte-4br9cw"),m(t,"id","items"),m(t,"class","svelte-4br9cw")},m(e,i){R(e,r,i),W(s,r,null),R(e,a,i),R(e,t,i),W(h,t,null),o=!0},p(e,[i]){const c={};i&15&&(c.$$scope={dirty:i,ctx:e}),s.$set(c);const l={};i&15&&(l.$$scope={dirty:i,ctx:e}),h.$set(l)},i(e){o||(k(s.$$.fragment,e),k(h.$$.fragment,e),o=!0)},o(e){I(s.$$.fragment,e),I(h.$$.fragment,e),o=!1},d(e){e&&u(r),D(s),e&&u(a),e&&u(t),D(h)}}}class Ie extends S{constructor(r){super(),j(this,r,null,_e,N,{})}}export{Ie as default};
